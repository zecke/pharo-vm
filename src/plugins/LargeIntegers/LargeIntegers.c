/* Automatically generated by
	SmartSyntaxPluginCodeGenerator VMMaker.oscog-jeanbaptistearnaud.782 uuid: 4529b9a2-dbec-4078-83aa-46de2ee4ed38
   from
	LargeIntegersPlugin VMMaker.oscog-jeanbaptistearnaud.782 uuid: 4529b9a2-dbec-4078-83aa-46de2ee4ed38
 */
static char __buildInfo[] = "LargeIntegersPlugin VMMaker.oscog-jeanbaptistearnaud.782 uuid: 4529b9a2-dbec-4078-83aa-46de2ee4ed38 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static sqInt anyBitOfBytesfromto(sqInt aBytesOop, sqInt start, sqInt stopArg);
static sqInt byteSizeOfBytes(sqInt bytesOop);
static sqInt bytesOrIntgrowTo(sqInt oop, sqInt len);
static sqInt bytesgrowTo(sqInt aBytesObject, sqInt newLen);
static sqInt bytesLshift(sqInt aBytesOop, sqInt shiftCount);
static sqInt bytesRshiftbyteslookfirst(sqInt aBytesOop, sqInt anInteger, sqInt b, sqInt a);
static sqInt cByteOpshortlenlongleninto(sqInt opIndex, unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes);
static int cBytesCopyFromtolen(unsigned char *  pFrom, unsigned char *  pTo, sqInt len);
static sqInt cBytesHighBitlen(unsigned char *   pByte, sqInt len);
static int cBytesLshiftfromlentolen(sqInt shiftCount, unsigned char *  pFrom, sqInt lenFrom, unsigned char *  pTo, sqInt lenTo);
static int cBytesReplacefromtowithstartingAt(unsigned char *  pTo, sqInt start, sqInt stop, unsigned char *  pFrom, sqInt repStart);
static sqInt cCopyIntValtoBytes(sqInt val, sqInt bytes);
static sqInt cCoreBytesRshiftCountnfbytesfromlentolen(sqInt count, sqInt n, sqInt f, sqInt b, unsigned char *  pFrom, sqInt fromLen, unsigned char *  pTo, sqInt toLen);
static sqInt cCoreDigitDivDivlenremlenquolen(unsigned char *  pDiv, sqInt divLen, unsigned char *  pRem, sqInt remLen, unsigned char *  pQuo, sqInt quoLen);
static unsigned char cDigitAddlenwithleninto(unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes);
static sqInt cDigitComparewithlen(unsigned char *  pFirst, unsigned char *  pSecond, sqInt len);
static sqInt cDigitLengthOfCSI(sqInt csi);
static unsigned char cDigitMultiplylenwithleninto(unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes);
static sqInt cDigitOfCSIat(sqInt csi, sqInt ix);
static sqInt cDigitSublenwithleninto(unsigned char *  pByteSmall, sqInt smallLen, unsigned char *  pByteLarge, sqInt largeLen, unsigned char *  pByteRes);
static sqInt cdigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned char *  pBytesFirst, sqInt firstLen, unsigned char *  pBytesSecond, sqInt secondLen, unsigned char *  pBytesThird, sqInt thirdLen, sqInt mInv, unsigned char *  pBytesRes);
static sqInt cHighBit(sqInt uint);
static sqInt createLargeFromSmallInteger(sqInt anOop);
static sqInt digitAddLargewith(sqInt firstInteger, sqInt secondInteger);
static sqInt digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx);
static sqInt digitCompareLargewith(sqInt firstInteger, sqInt secondInteger);
static sqInt digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg);
static sqInt digitLength(sqInt oop);
static sqInt digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, sqInt mInv);
static sqInt digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg);
static sqInt digitOfBytesat(sqInt aBytesOop, sqInt ix);
static sqInt digitOfat(sqInt oop, sqInt ix);
static sqInt digitSubLargewith(sqInt firstInteger, sqInt secondInteger);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
static sqInt highBitOfBytes(sqInt aBytesOop);
static sqInt isNormalized(sqInt anInteger);
static sqInt msg(char *s);
static sqInt negative(sqInt aLarge);
static sqInt normalizeNegative(sqInt aLargeNegativeInteger);
static sqInt normalizePositive(sqInt aLargePositiveInteger);
static sqInt normalize(sqInt aLargeInteger);
EXPORT(sqInt) primAnyBitFromTo(void);
EXPORT(sqInt) primAsLargeInteger(void);
EXPORT(sqInt) primCheckIfCModuleExists(void);
EXPORT(sqInt) primDigitAdd(void);
EXPORT(sqInt) primDigitAddWith(void);
EXPORT(sqInt) primDigitBitAnd(void);
EXPORT(sqInt) primDigitBitLogicWithOp(void);
EXPORT(sqInt) primDigitBitOr(void);
EXPORT(sqInt) primDigitBitShift(void);
EXPORT(sqInt) primDigitBitShiftMagnitude(void);
EXPORT(sqInt) primDigitBitXor(void);
EXPORT(sqInt) primDigitCompare(void);
EXPORT(sqInt) primDigitCompareWith(void);
EXPORT(sqInt) primDigitDivNegative(void);
EXPORT(sqInt) primDigitDivWithNegative(void);
EXPORT(sqInt) primDigitMultiplyNegative(void);
EXPORT(sqInt) primDigitMultiplyWithNegative(void);
EXPORT(sqInt) primDigitSubtract(void);
EXPORT(sqInt) primDigitSubtractWith(void);
EXPORT(sqInt) primGetModuleName(void);
EXPORT(sqInt) primMontgomeryTimesModulo(void);
EXPORT(sqInt) primNormalize(void);
EXPORT(sqInt) primNormalizeNegative(void);
EXPORT(sqInt) primNormalizePositive(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
static sqInt sqAssert(sqInt aBool);
static sqInt think(void);
static sqInt unsafeByteOfat(sqInt bytesOop, sqInt ix);
EXPORT(sqInt) _primDigitBitShift(void);


/*** Variables ***/
static const int  andOpIndex = 0;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*classArray)(void);
static sqInt (*classLargeNegativeInteger)(void);
static sqInt (*classLargePositiveInteger)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static sqInt (*integerValueOf)(sqInt oop);
static sqInt (*isKindOf)(sqInt oop, char *aString);
static sqInt (*isIntegerObject)(sqInt objectPointer);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*primitiveFail)(void);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stObjectatput)(sqInt array, sqInt index, sqInt value);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*success)(sqInt aBoolean);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt classArray(void);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern sqInt fetchClassOf(sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
extern sqInt isKindOf(sqInt oop, char *aString);
extern sqInt isIntegerObject(sqInt objectPointer);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt primitiveFail(void);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt success(sqInt aBoolean);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"LargeIntegers v1.5 VMMaker.oscog-jeanbaptistearnaud.782 (i)"
#else
	"LargeIntegers v1.5 VMMaker.oscog-jeanbaptistearnaud.782 (e)"
#endif
;
static const int  orOpIndex = 1;
static const int  xorOpIndex = 2;



/*	Argument has to be aBytesOop! */
/*	Tests for any magnitude bits in the interval from start to stopArg. */

static sqInt
anyBitOfBytesfromto(sqInt aBytesOop, sqInt start, sqInt stopArg)
{
	// LargeIntegersPlugin>>#anyBitOfBytes:from:to:
	sqInt digit;
	sqInt firstByteIx;
	sqInt ix;
	sqInt lastByteIx;
	sqInt leftShift;
	sqInt magnitude;
	sqInt mask;
	unsigned char *pointer;
	sqInt rightShift;
	sqInt stop;

	/* missing DebugCode */;
	if ((start < 1) || (stopArg < 1)) {
		return primitiveFail();
	}
	magnitude = aBytesOop;
	stop = ((stopArg < (cBytesHighBitlen(firstIndexableField(magnitude), slotSizeOf(magnitude)))) ? stopArg : (cBytesHighBitlen(firstIndexableField(magnitude), slotSizeOf(magnitude))));
	if (start > stop) {
return 0;
	}
	firstByteIx = (((sqInt) (start - 1) >> 3)) + 1;
	lastByteIx = (((sqInt) (stop - 1) >> 3)) + 1;
	rightShift = (start - 1) % 8;
	leftShift = 7 - ((stop - 1) % 8);
	if (firstByteIx == lastByteIx) {
mask = (0xFF << rightShift) & (((usqInt) 0xFF) >> leftShift);
		/* begin digitOfBytes:at: */
		if (firstByteIx > (slotSizeOf(magnitude))) {
			digit = 0;
			goto l1;
		}
		else {
digit = ((pointer = firstIndexableField(magnitude)))[firstByteIx - 1];
			goto l1;
		}
	l1:	/* end digitOfBytes:at: */;
		return (digit & mask) != 0;
	}
	if ((((usqInt) (digitOfBytesat(magnitude, firstByteIx))) >> rightShift) != 0) {
		return 1;
	}
	for (ix = (firstByteIx + 1); ix < lastByteIx; ix += 1) {
		if ((digitOfBytesat(magnitude, ix)) != 0) {
			return 1;
		}
	}
	if ((((digitOfBytesat(magnitude, lastByteIx)) << leftShift) & 0xFF) != 0) {
		return 1;
	}
	return 0;
}


/*	Precondition: bytesOop is not anInteger and a bytes object. */
/*	Function #byteSizeOf: is used by the interpreter, be careful with name
	clashes... */

static sqInt
byteSizeOfBytes(sqInt bytesOop)
{
	// LargeIntegersPlugin>>#byteSizeOfBytes:
	return slotSizeOf(bytesOop);
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */

static sqInt
bytesOrIntgrowTo(sqInt oop, sqInt len)
{
	// LargeIntegersPlugin>>#bytesOrInt:growTo:
	sqInt class;
	sqInt ix;
	sqInt ixLimiT;
	sqInt newBytes;
	unsigned char *   pByte;
	sqInt val;

	if (isIntegerObject(oop)) {
		val = integerValueOf(oop);
		if (val < 0) {
class = classLargeNegativeInteger();
		}
		else {
class = classLargePositiveInteger();
		}
		newBytes = instantiateClassindexableSize(class, len);
		/* begin cCopyIntVal:toBytes: */
		pByte = firstIndexableField(newBytes);
		for (ix = 1, ixLimiT = (cDigitLengthOfCSI(val)); ix <= ixLimiT; ix += 1) {
			pByte[ix - 1] = (cDigitOfCSIat(val, ix));
		}
	}
	else {
newBytes = bytesgrowTo(oop, len);
	}
	return newBytes;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Does not normalize. */

static sqInt
bytesgrowTo(sqInt aBytesObject, sqInt newLen)
{
	// LargeIntegersPlugin>>#bytes:growTo:
	sqInt copyLen;
	sqInt newBytes;
	sqInt oldLen;

	pushRemappableOop(aBytesObject);
newBytes = instantiateClassindexableSize(fetchClassOf(aBytesObject), newLen);
	aBytesObject = popRemappableOop();
	oldLen = slotSizeOf(aBytesObject);
	if (oldLen < newLen) {
copyLen = oldLen;
	}
	else {
copyLen = newLen;
	}
	cBytesCopyFromtolen(firstIndexableField(aBytesObject), firstIndexableField(newBytes), copyLen);
	return newBytes;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Does not normalize. */

static sqInt
bytesLshift(sqInt aBytesOop, sqInt shiftCount)
{
	// LargeIntegersPlugin>>#bytes:Lshift:
	sqInt bitShift;
	sqInt byteShift;
	sqInt carry;
	sqInt digit;
	sqInt highBit;
	sqInt i;
	sqInt lastIx;
	sqInt limit;
	sqInt newBytes;
	sqInt newLen;
	sqInt oldLen;
	unsigned char *  pFrom;
	unsigned char *  pTo;

	oldLen = slotSizeOf(aBytesOop);
	if (((highBit = cBytesHighBitlen(firstIndexableField(aBytesOop), oldLen))) == 0) {
		return integerObjectOf(0);
	}
	newLen = ((sqInt) ((highBit + shiftCount) + 7) >> 3);
	pushRemappableOop(aBytesOop);
newBytes = instantiateClassindexableSize(fetchClassOf(aBytesOop), newLen);
	aBytesOop = popRemappableOop();
	/* begin cBytesLshift:from:len:to:len: */
	pFrom = firstIndexableField(aBytesOop);
	pTo = firstIndexableField(newBytes);
	byteShift = ((sqInt) shiftCount >> 3);
	bitShift = shiftCount % 8;
	if (bitShift == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */

/* begin cBytesReplace:from:to:with:startingAt: */
		cBytesCopyFromtolen(pFrom + 0, pTo + byteShift, ((newLen - 1) - byteShift) + 1);
		goto l1;
	}
	carry = 0;
	limit = byteShift - 1;
	for (i = 0; i <= limit; i += 1) {
pTo[i] = 0;
	}
	limit = (newLen - byteShift) - 2;
	/* begin sqAssert: */
	/* missing DebugCode */;
l2:	/* end sqAssert: */;
	for (i = 0; i <= limit; i += 1) {
digit = pFrom[i];
		carry = (((usqInt) carry) >> 8) | (digit << bitShift);
		pTo[i + byteShift] = (carry & 0xFF);
	}
	lastIx = limit + 1;
	if (lastIx > (oldLen - 1)) {
		digit = 0;
	}
	else {
digit = pFrom[lastIx];
	}
	carry = (((usqInt) carry) >> 8) | (digit << bitShift);
	pTo[lastIx + byteShift] = carry;
	carry = ((usqInt) carry) >> 8;
	/* begin sqAssert: */
	/* missing DebugCode */;
l3:	/* end sqAssert: */;
l1:	/* end cBytesLshift:from:len:to:len: */;
	return newBytes;
}


/*	Attention: this method invalidates all oop's! Only newBytes is valid at
	return. 
 */
/*	Shift right 8*b+anInteger bits, 0<=n<8. 
	Discard all digits beyond a, and all zeroes at or below a. */
/*	Does not normalize. */

static sqInt
bytesRshiftbyteslookfirst(sqInt aBytesOop, sqInt anInteger, sqInt b, sqInt a)
{
	// LargeIntegersPlugin>>#bytes:Rshift:bytes:lookfirst:
	sqInt digit;
	sqInt digit1;
	sqInt f;
	sqInt i;
	sqInt j;
	sqInt newBytes;
	sqInt newLen;
	sqInt oldLen;
	unsigned char *  pFrom;
	unsigned char *pointer;
	unsigned char *pointer1;
	unsigned char *  pTo;
	sqInt x;
	sqInt x1;

	x = 0;
	f = 8 - anInteger;
	i = a;
	/* begin digitOfBytes:at: */
	if (i > (slotSizeOf(aBytesOop))) {
		digit = 0;
		goto l2;
	}
	else {
digit = ((pointer1 = firstIndexableField(aBytesOop)))[i - 1];
		goto l2;
	}
l2:	/* end digitOfBytes:at: */;
	while ((((((usqInt) digit) >> anInteger) | x) == 0)
	 && (i != 1)) {

		/* Can't exceed 8 bits */

x = digit << f;
		i -= 1;
		/* begin digitOfBytes:at: */
		if (i > (slotSizeOf(aBytesOop))) {
			digit = 0;
			goto l1;
		}
		else {
digit = ((pointer = firstIndexableField(aBytesOop)))[i - 1];
			goto l1;
		}
	l1:	/* end digitOfBytes:at: */;
	}
	if (i <= b) {
return instantiateClassindexableSize(fetchClassOf(aBytesOop), 0);
	}
	oldLen = slotSizeOf(aBytesOop);
	newLen = i - b;
	pushRemappableOop(aBytesOop);
newBytes = instantiateClassindexableSize(fetchClassOf(aBytesOop), newLen);
	aBytesOop = popRemappableOop();
	/* begin cCoreBytesRshiftCount:n:f:bytes:from:len:to:len: */
	pFrom = firstIndexableField(aBytesOop);
	pTo = firstIndexableField(newBytes);
	/* begin sqAssert: */
	/* missing DebugCode */;
l3:	/* end sqAssert: */;
	if (anInteger == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */

/* begin cBytesReplace:from:to:with:startingAt: */
		((int) (cBytesCopyFromtolen(pFrom + b, pTo + 0, ((newLen - 1) - 0) + 1)));
		goto l5;
	}
	x1 = (pFrom[b]) << f;
	/* begin sqAssert: */
	/* missing DebugCode */;
l4:	/* end sqAssert: */;
	for (j = (b + 1); j < i; j += 1) {
		digit1 = pFrom[j];
		x1 = (((usqInt) x1) >> 8) | (digit1 << f);
		pTo[(j - b) - 1] = (x1 & 0xFF);
	}
	if (i == oldLen) {
digit1 = 0;
	}
	else {
digit1 = pFrom[i];
	}
	x1 = (((usqInt) x1) >> 8) | (digit1 << f);
	pTo[(i - b) - 1] = x1;
l5:	/* end cCoreBytesRshiftCount:n:f:bytes:from:len:to:len: */;
	return newBytes;
}


/*	pByteRes len = longLen. */

static sqInt
cByteOpshortlenlongleninto(sqInt opIndex, unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes)
{
	// LargeIntegersPlugin>>#cByteOp:short:len:long:len:into:
	sqInt i;
	sqInt limit;

	limit = shortLen - 1;
	if (opIndex == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) & (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = 0;
		}
		return 0;
	}
	if (opIndex == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) | (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = (pByteLong[i]);
		}
		return 0;
	}
	if (opIndex == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) ^ (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = (pByteLong[i]);
		}
		return 0;
	}
	return primitiveFail();
}

static int
cBytesCopyFromtolen(unsigned char *  pFrom, unsigned char *  pTo, sqInt len)
{
	// LargeIntegersPlugin>>#cBytesCopyFrom:to:len:
	sqInt i;
	sqInt limit;

	
limit = len - 1;
	for (i = 0; i <= limit; i += 1) {
pTo[i] = (pFrom[i]);
	}
	return 0;
}


/*	Answer the index (in bits) of the high order bit of the receiver, or zero
	if the 
	receiver is zero. This method is allowed (and needed) for 
	LargeNegativeIntegers as well, since Squeak's LargeIntegers are 
	sign/magnitude. */

static sqInt
cBytesHighBitlen(unsigned char *   pByte, sqInt len)
{
	// LargeIntegersPlugin>>#cBytesHighBit:len:
	sqInt lastDigit;
	sqInt realLength;

	realLength = len;
	while (((lastDigit = pByte[realLength - 1])) == 0) {
		if (((realLength -= 1)) == 0) {
			return 0;
		}
	}
	return (cHighBit(lastDigit)) + (8 * (realLength - 1));
}


/*	C indexed! */

static int
cBytesLshiftfromlentolen(sqInt shiftCount, unsigned char *  pFrom, sqInt lenFrom, unsigned char *  pTo, sqInt lenTo)
{
	// LargeIntegersPlugin>>#cBytesLshift:from:len:to:len:
	sqInt bitShift;
	sqInt byteShift;
	sqInt carry;
	sqInt digit;
	sqInt i;
	sqInt lastIx;
	sqInt limit;

	byteShift = ((sqInt) shiftCount >> 3);
	bitShift = shiftCount % 8;
	if (bitShift == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */

/* begin cBytesReplace:from:to:with:startingAt: */
		return cBytesCopyFromtolen(pFrom + 0, pTo + byteShift, ((lenTo - 1) - byteShift) + 1);
	}
	carry = 0;
	limit = byteShift - 1;
	for (i = 0; i <= limit; i += 1) {
pTo[i] = 0;
	}
	limit = (lenTo - byteShift) - 2;
	/* begin sqAssert: */
	/* missing DebugCode */;
l1:	/* end sqAssert: */;
	for (i = 0; i <= limit; i += 1) {
digit = pFrom[i];
		carry = (((usqInt) carry) >> 8) | (digit << bitShift);
		pTo[i + byteShift] = (carry & 0xFF);
	}
	lastIx = limit + 1;
	if (lastIx > (lenFrom - 1)) {
		digit = 0;
	}
	else {
digit = pFrom[lastIx];
	}
	carry = (((usqInt) carry) >> 8) | (digit << bitShift);
	pTo[lastIx + byteShift] = carry;
	carry = ((usqInt) carry) >> 8;
	/* begin sqAssert: */
	/* missing DebugCode */;
l2:	/* end sqAssert: */;
}


/*	C indexed! */

static int
cBytesReplacefromtowithstartingAt(unsigned char *  pTo, sqInt start, sqInt stop, unsigned char *  pFrom, sqInt repStart)
{
	// LargeIntegersPlugin>>#cBytesReplace:from:to:with:startingAt:
	return cBytesCopyFromtolen(pFrom + repStart, pTo + start, (stop - start) + 1);
}

static sqInt
cCopyIntValtoBytes(sqInt val, sqInt bytes)
{
	// LargeIntegersPlugin>>#cCopyIntVal:toBytes:
	sqInt ix;
	sqInt ixLimiT;
	unsigned char *   pByte;

	pByte = firstIndexableField(bytes);
	for (ix = 1, ixLimiT = (cDigitLengthOfCSI(val)); ix <= ixLimiT; ix += 1) {
		pByte[ix - 1] = (cDigitOfCSIat(val, ix));
	}
}

static sqInt
cCoreBytesRshiftCountnfbytesfromlentolen(sqInt count, sqInt n, sqInt f, sqInt b, unsigned char *  pFrom, sqInt fromLen, unsigned char *  pTo, sqInt toLen)
{
	// LargeIntegersPlugin>>#cCoreBytesRshiftCount:n:f:bytes:from:len:to:len:
	sqInt digit;
	sqInt j;
	sqInt x;

	/* begin sqAssert: */
	/* missing DebugCode */;
l1:	/* end sqAssert: */;
	if (n == 0) {

		/* Fast version for byte-aligned shifts */
		/* C indexed! */

/* begin cBytesReplace:from:to:with:startingAt: */
		return ((int) (cBytesCopyFromtolen(pFrom + b, pTo + 0, ((toLen - 1) - 0) + 1)));
	}
	x = (pFrom[b]) << f;
	/* begin sqAssert: */
	/* missing DebugCode */;
l2:	/* end sqAssert: */;
	for (j = (b + 1); j < count; j += 1) {
		digit = pFrom[j];
		x = (((usqInt) x) >> 8) | (digit << f);
		pTo[(j - b) - 1] = (x & 0xFF);
	}
	if (count == fromLen) {
digit = 0;
	}
	else {
digit = pFrom[count];
	}
	x = (((usqInt) x) >> 8) | (digit << f);
	pTo[(count - b) - 1] = x;
}

static sqInt
cCoreDigitDivDivlenremlenquolen(unsigned char *  pDiv, sqInt divLen, unsigned char *  pRem, sqInt remLen, unsigned char *  pQuo, sqInt quoLen)
{
	// LargeIntegersPlugin>>#cCoreDigitDivDiv:len:rem:len:quo:len:
	sqInt a;
	sqInt cond;
	sqInt dh;
	sqInt dl;
	sqInt dnh;
	sqInt hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	sqInt lo;
	sqInt mul;
	sqInt q;
	sqInt ql;
	sqInt r1r2;
	sqInt r3;
	sqInt t;


	/* Last actual byte of data (ST ix) */

dl = divLen - 1;
	ql = quoLen;
	dh = pDiv[dl - 1];
	if (dl == 1) {
dnh = 0;
	}
	else {
dnh = pDiv[dl - 2];
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two bytes of rem by dh. */
		/* The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles. */
		/* Nibbles are kicked off! We use full 16 bits now, because we are in
		   the year 2000 ;-) [sr] */
		/* r1 := rem digitAt: j. */


		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two bytes of rem by dh. */
		/* The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles. */
		/* Nibbles are kicked off! We use full 16 bits now, because we are in
		   the year 2000 ;-) [sr] */
		/* r1 := rem digitAt: j. */

j = (remLen + 1) - k;
		if ((pRem[j - 1]) == dh) {
			q = 0xFF;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are bytes, not nibbles.
			   Be careful not to generate intermediate results exceeding 13
			   bits. */
			/* r2 := (rem digitAt: j - 2). */


			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are bytes, not nibbles.
			   Be careful not to generate intermediate results exceeding 13
			   bits. */
			/* r2 := (rem digitAt: j - 2). */

r1r2 = (((usqInt) (pRem[j - 1]) << 8)) + (pRem[j - 2]);
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */

q = r1r2 / dh;
			mul = q * dnh;
			hi = ((usqInt) mul >> 8);

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */

			lo = mul & 0xFF;
			if (j < 3) {
r3 = 0;
			}
			else {
r3 = pRem[j - 3];
			}
			while (1) {
if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */


					/* i.e. (t,r3) < (hi,lo) */

q -= 1;
					lo -= dnh;
					if (lo < 0) {
hi -= 1;
						lo += 256;
					}
					cond = hi >= dh;
				}
				else {
cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
hi = (pDiv[i - 1]) * (((usqInt) q >> 8));

			/* pRem at: l - 1 put: lo - (lo // 256 * 256). */
			/* sign-tolerant form of (lo bitAnd: 255) -> obsolete... */

lo = (a + (pRem[l - 1])) - ((pDiv[i - 1]) * (q & 0xFF));
			pRem[l - 1] = (lo & 0xFF);
			a = (((sqInt) lo >> 8)) - hi;
			l += 1;
		}
		if (a < 0) {

			/* Add div back into rem, decrease q by 1 */


			/* Add div back into rem, decrease q by 1 */

q -= 1;
			l = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
a = ((((usqInt) a >> 8)) + (pRem[l - 1])) + (pDiv[i - 1]);
				pRem[l - 1] = (a & 0xFF);
				l += 1;
			}
		}
		pQuo[quoLen - k] = q;
	}
}


/*	pByteRes len = longLen; returns over.. */

static unsigned char
cDigitAddlenwithleninto(unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes)
{
	// LargeIntegersPlugin>>#cDigitAdd:len:with:len:into:
	sqInt accum;
	sqInt i;
	sqInt limit;

	accum = 0;
	limit = shortLen - 1;
	for (i = 0; i <= limit; i += 1) {
accum = ((((usqInt) accum >> 8)) + (pByteShort[i])) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	limit = longLen - 1;
	for (i = shortLen; i <= limit; i += 1) {
accum = (((usqInt) accum >> 8)) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	return ((usqInt) accum >> 8);
}


/*	Precondition: pFirst len = pSecond len. */

static sqInt
cDigitComparewithlen(unsigned char *  pFirst, unsigned char *  pSecond, sqInt len)
{
	// LargeIntegersPlugin>>#cDigitCompare:with:len:
	sqInt firstDigit;
	sqInt ix;
	sqInt secondDigit;

	ix = len - 1;
	while (ix >= 0) {
if (((secondDigit = pSecond[ix])) != ((firstDigit = pFirst[ix]))) {
			if (secondDigit < firstDigit) {
return 1;
			}
			else {
return -1;
			}
		}
		ix -= 1;
	}
	return 0;
}


/*	Answer the number of indexable fields of a CSmallInteger. This value is 
	the same as the largest legal subscript. */

static sqInt
cDigitLengthOfCSI(sqInt csi)
{
	// LargeIntegersPlugin>>#cDigitLengthOfCSI:
	if ((csi < 256)
	 && (csi > -256)) {
		return 1;
	}
	if ((csi < 65536)
	 && (csi > -65536)) {
		return 2;
	}
	if ((csi < 0x1000000)
	 && (csi > -16777216)) {
		return 3;
	}
	return 4;
}

static unsigned char
cDigitMultiplylenwithleninto(unsigned char *  pByteShort, sqInt shortLen, unsigned char *  pByteLong, sqInt longLen, unsigned char *  pByteRes)
{
	// LargeIntegersPlugin>>#cDigitMultiply:len:with:len:into:
	sqInt ab;
	sqInt carry;
	sqInt digit;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;

	if ((shortLen == 1)
	 && ((pByteShort[0]) == 0)) {
		return 0;
	}
	if ((longLen == 1)
	 && ((pByteLong[0]) == 0)) {
		return 0;
	}
	limitShort = shortLen - 1;
	for (i = 0; i <= limitShort; i += 1) {
if (((digit = pByteShort[i])) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=0377, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=0377, k=i+j (C) (?) */

carry = 0;
			limitLong = longLen - 1;
			for (j = 0; j <= limitLong; j += 1) {
ab = (((pByteLong[j]) * digit) + carry) + (pByteRes[k]);
				carry = ((usqInt) ab >> 8);
				pByteRes[k] = (ab & 0xFF);
				k += 1;
			}
			pByteRes[k] = carry;
		}
	}
	return 0;
}


/*	Answer the value of an indexable field in the receiver. 
	LargePositiveInteger uses bytes of base two number, and each is a 
	'digit' base 256. */
/*	ST indexed! */

static sqInt
cDigitOfCSIat(sqInt csi, sqInt ix)
{
	// LargeIntegersPlugin>>#cDigitOfCSI:at:
	if (ix < 1) {
primitiveFail();
	}
	if (ix > 4) {
return 0;
	}
	if (csi < 0) {
;
		return (((usqInt) (0 - csi)) >> ((ix - 1) * 8)) & 0xFF;
	}
	else {
return (((usqInt) csi) >> ((ix - 1) * 8)) & 0xFF;
	}
}

static sqInt
cDigitSublenwithleninto(unsigned char *  pByteSmall, sqInt smallLen, unsigned char *  pByteLarge, sqInt largeLen, unsigned char *  pByteRes)
{
	// LargeIntegersPlugin>>#cDigitSub:len:with:len:into:
	sqInt i;
	sqInt limit;
	sqInt z;


	/* Loop invariant is -1<=z<=1 */

z = 0;
	limit = smallLen - 1;
	for (i = 0; i <= limit; i += 1) {
z = (z + (pByteLarge[i])) - (pByteSmall[i]);
		pByteRes[i] = (z - ((((sqInt) z >> 8)) * 256));
		z = ((sqInt) z >> 8);
	}
	limit = largeLen - 1;
	for (i = smallLen; i <= limit; i += 1) {
z += pByteLarge[i];
		pByteRes[i] = (z - ((((sqInt) z >> 8)) * 256));
		z = ((sqInt) z >> 8);
	}
}

static sqInt
cdigitMontgomerylentimeslenmodulolenmInvModBinto(unsigned char *  pBytesFirst, sqInt firstLen, unsigned char *  pBytesSecond, sqInt secondLen, unsigned char *  pBytesThird, sqInt thirdLen, sqInt mInv, unsigned char *  pBytesRes)
{
	// LargeIntegersPlugin>>#cdigitMontgomery:len:times:len:modulo:len:mInvModB:into:
	usqInt  accum;
	sqInt i;
	sqInt k;
	unsigned char   lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char   u;

	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
accum = pBytesRes[0];
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */


		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */

accum = 0;
		for (i = 0; i <= limit3; i += 1) {
accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = (accum - ((((sqInt) accum >> 8)) * 256));
			accum = ((sqInt) accum >> 8);
		}
	}
}


/*	Answer the index of the high order bit of the argument, or zero if the 
	argument is zero. */
/*	For 64 bit uints there could be added a 32-shift. */

static sqInt
cHighBit(sqInt uint)
{
	// LargeIntegersPlugin>>#cHighBit:
	sqInt bitNo;
	unsigned int   shifted;

	shifted = uint;
	bitNo = 0;
	if (!(shifted < (1 << 16))) {
		shifted = ((usqInt) shifted >> 16);
		bitNo += 16;
	}
	if (!(shifted < (1 << 8))) {
		shifted = ((usqInt) shifted >> 8);
		bitNo += 8;
	}
	if (!(shifted < (1 << 4))) {
		shifted = ((usqInt) shifted >> 4);
		bitNo += 4;
	}
	if (!(shifted < (1 << 2))) {
		shifted = ((usqInt) shifted >> 2);
		bitNo += 2;
	}
	if (!(shifted < (1 << 1))) {
		shifted = ((usqInt) shifted >> 1);
		bitNo += 1;
	}
	return bitNo + shifted;
}


/*	anOop has to be a SmallInteger! */

static sqInt
createLargeFromSmallInteger(sqInt anOop)
{
	// LargeIntegersPlugin>>#createLargeFromSmallInteger:
	sqInt class;
	sqInt ix;
	unsigned char *   pByte;
	sqInt res;
	sqInt size;
	sqInt val;

	val = integerValueOf(anOop);
	if (val < 0) {
class = classLargeNegativeInteger();
	}
	else {
class = classLargePositiveInteger();
	}
	/* begin cDigitLengthOfCSI: */
	if ((val < 256)
	 && (val > -256)) {
		size = 1;
		goto l1;
	}
	if ((val < 65536)
	 && (val > -65536)) {
		size = 2;
		goto l1;
	}
	if ((val < 0x1000000)
	 && (val > -16777216)) {
		size = 3;
		goto l1;
	}
	size = 4;
l1:	/* end cDigitLengthOfCSI: */;
	res = instantiateClassindexableSize(class, size);
	pByte = firstIndexableField(res);
	for (ix = 1; ix <= size; ix += 1) {
pByte[ix - 1] = (cDigitOfCSIat(val, ix));
	}
	return res;
}


/*	Does not need to normalize! */

static sqInt
digitAddLargewith(sqInt firstInteger, sqInt secondInteger)
{
	// LargeIntegersPlugin>>#digitAddLarge:with:
	sqInt accum;
	sqInt firstLen;
	sqInt i;
	sqInt limit;
	sqInt longInt;
	sqInt longLen;
	sqInt newSum;
	unsigned char   over;
	unsigned char *  pByteLong;
	unsigned char *  pByteRes;
	unsigned char *  pByteShort;
	sqInt resClass;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;
	sqInt sum;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	resClass = fetchClassOf(firstInteger);
	if (firstLen <= secondLen) {
shortInt = firstInteger;
		shortLen = firstLen;
		longInt = secondInteger;
		longLen = secondLen;
	}
	else {
shortInt = secondInteger;
		shortLen = secondLen;
		longInt = firstInteger;
		longLen = firstLen;
	}
	pushRemappableOop(shortInt);
	pushRemappableOop(longInt);
sum = instantiateClassindexableSize(resClass, longLen);
	longInt = popRemappableOop();
	shortInt = popRemappableOop();
	/* begin cDigitAdd:len:with:len:into: */
	pByteShort = firstIndexableField(shortInt);
	pByteLong = firstIndexableField(longInt);
	pByteRes = firstIndexableField(sum);
	accum = 0;
	limit = shortLen - 1;
	for (i = 0; i <= limit; i += 1) {
accum = ((((usqInt) accum >> 8)) + (pByteShort[i])) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	limit = longLen - 1;
	for (i = shortLen; i <= limit; i += 1) {
accum = (((usqInt) accum >> 8)) + (pByteLong[i]);
		pByteRes[i] = (accum & 0xFF);
	}
	over = ((usqInt) accum >> 8);
	if (over > 0) {

		/* sum := sum growby: 1. */

pushRemappableOop(sum);

		/* sum := sum growby: 1. */


		/* sum := sum growby: 1. */

newSum = instantiateClassindexableSize(resClass, longLen + 1);
		sum = popRemappableOop();
		cBytesCopyFromtolen(firstIndexableField(sum), firstIndexableField(newSum), longLen);

		/* C index! */

sum = newSum;
		(((unsigned char *) (firstIndexableField(sum))))[longLen] = over;
	}
	return sum;
}


/*	Bit logic here is only implemented for positive integers or Zero;
	if rec or arg is negative, it fails. */

static sqInt
digitBitLogicwithopIndex(sqInt firstInteger, sqInt secondInteger, sqInt opIx)
{
	// LargeIntegersPlugin>>#digitBitLogic:with:opIndex:
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt limit;
	sqInt longLarge;
	sqInt longLen;
	unsigned char *  pByteLong;
	unsigned char *  pByteRes;
	unsigned char *  pByteShort;
	sqInt result;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt shortLarge;
	sqInt shortLen;

	if (isIntegerObject(firstInteger)) {
		if ((integerValueOf(firstInteger)) < 0) {
			return primitiveFail();
		}
		pushRemappableOop(secondInteger);
firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
if ((fetchClassOf(firstInteger)) == (classLargeNegativeInteger())) {
			return primitiveFail();
		}
		firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {
		if ((integerValueOf(secondInteger)) < 0) {
			return primitiveFail();
		}
		pushRemappableOop(firstLarge);
secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
if ((fetchClassOf(secondInteger)) == (classLargeNegativeInteger())) {
			return primitiveFail();
		}
		secondLarge = secondInteger;
	}
	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	if (firstLen < secondLen) {
shortLen = firstLen;
		shortLarge = firstLarge;
		longLen = secondLen;
		longLarge = secondLarge;
	}
	else {
shortLen = secondLen;
		shortLarge = secondLarge;
		longLen = firstLen;
		longLarge = firstLarge;
	}
	pushRemappableOop(shortLarge);
	pushRemappableOop(longLarge);
result = instantiateClassindexableSize(classLargePositiveInteger(), longLen);
	longLarge = popRemappableOop();
	shortLarge = popRemappableOop();
	/* begin cByteOp:short:len:long:len:into: */
	pByteShort = firstIndexableField(shortLarge);
	pByteLong = firstIndexableField(longLarge);
	pByteRes = firstIndexableField(result);
	limit = shortLen - 1;
	if (opIx == andOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) & (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = 0;
		}
		0;
		goto l1;
	}
	if (opIx == orOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) | (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = (pByteLong[i]);
		}
		0;
		goto l1;
	}
	if (opIx == xorOpIndex) {
		for (i = 0; i <= limit; i += 1) {
pByteRes[i] = ((pByteShort[i]) ^ (pByteLong[i]));
		}
		limit = longLen - 1;
		for (i = shortLen; i <= limit; i += 1) {
pByteRes[i] = (pByteLong[i]);
		}
		0;
		goto l1;
	}
	primitiveFail();
l1:	/* end cByteOp:short:len:long:len:into: */;
	if (failed()) {
		return 0;
	}
	return normalizePositive(result);
}


/*	Compare the magnitude of firstInteger with that of secondInteger. 
	Return a code of 1, 0, -1 for firstInteger >, = , < secondInteger */

static sqInt
digitCompareLargewith(sqInt firstInteger, sqInt secondInteger)
{
	// LargeIntegersPlugin>>#digitCompareLarge:with:
	sqInt firstLen;
	sqInt secondLen;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (secondLen != firstLen) {
if (secondLen > firstLen) {
return integerObjectOf(-1);
		}
		else {
return integerObjectOf(1);
		}
	}
	return integerObjectOf((cDigitComparewithlen(firstIndexableField(firstInteger), firstIndexableField(secondInteger), firstLen)));
}


/*	Does not normalize. */
/*	Division by zero has to be checked in caller. */

static sqInt
digitDivLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg)
{
	// LargeIntegersPlugin>>#digitDivLarge:with:negative:
	sqInt a;
	sqInt cond;
	sqInt d;
	sqInt dh;
	sqInt div;
	sqInt divLen;
	sqInt dl;
	sqInt dnh;
	sqInt firstLen;
	sqInt hi;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt l;
	sqInt l1;
	sqInt lo;
	sqInt mul;
	unsigned char *  pDiv;
	unsigned char *pointer;
	unsigned char *  pQuo;
	unsigned char *  pRem;
	sqInt q;
	sqInt ql;
	sqInt quo;
	sqInt quoLen;
	sqInt r1r2;
	sqInt r3;
	sqInt rem;
	sqInt remLen;
	sqInt result;
	sqInt resultClass;
	sqInt secondLen;
	sqInt t;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (neg) {
resultClass = classLargeNegativeInteger();
	}
	else {
resultClass = classLargePositiveInteger();
	}
	l = (firstLen - secondLen) + 1;
	if (l <= 0) {
pushRemappableOop(firstInteger);
result = instantiateClassindexableSize(classArray(), 2);
		firstInteger = popRemappableOop();
		stObjectatput(result,1,(integerObjectOf(0)));
		stObjectatput(result,2,firstInteger);
		return result;
	}
	d = 8 - (cHighBit(((pointer = firstIndexableField(secondInteger)))[secondLen - 1]));
	pushRemappableOop(firstInteger);
div = bytesLshift(secondInteger, d);
	div = bytesOrIntgrowTo(div, (digitLength(div)) + 1);
	firstInteger = popRemappableOop();
	pushRemappableOop(div);
rem = bytesLshift(firstInteger, d);
	if ((digitLength(rem)) == firstLen) {
		rem = bytesOrIntgrowTo(rem, firstLen + 1);
	}
	div = popRemappableOop();
	pushRemappableOop(div);
	pushRemappableOop(rem);
quo = instantiateClassindexableSize(resultClass, l);
	rem = popRemappableOop();
	div = popRemappableOop();
	/* begin cCoreDigitDivDiv:len:rem:len:quo:len: */
	pDiv = firstIndexableField(div);
	/* begin digitLength: */
	if (isIntegerObject(div)) {
		/* begin cDigitLengthOfCSI: */
		if (((integerValueOf(div)) < 256)
		 && ((integerValueOf(div)) > -256)) {
			divLen = 1;
			goto l1;
		}
		if (((integerValueOf(div)) < 65536)
		 && ((integerValueOf(div)) > -65536)) {
			divLen = 2;
			goto l1;
		}
		if (((integerValueOf(div)) < 0x1000000)
		 && ((integerValueOf(div)) > -16777216)) {
			divLen = 3;
			goto l1;
		}
		divLen = 4;
		goto l1;
	}
	else {
divLen = slotSizeOf(div);
		goto l1;
	}
l1:	/* end digitLength: */;
	pRem = firstIndexableField(rem);
	/* begin digitLength: */
	if (isIntegerObject(rem)) {
		/* begin cDigitLengthOfCSI: */
		if (((integerValueOf(rem)) < 256)
		 && ((integerValueOf(rem)) > -256)) {
			remLen = 1;
			goto l2;
		}
		if (((integerValueOf(rem)) < 65536)
		 && ((integerValueOf(rem)) > -65536)) {
			remLen = 2;
			goto l2;
		}
		if (((integerValueOf(rem)) < 0x1000000)
		 && ((integerValueOf(rem)) > -16777216)) {
			remLen = 3;
			goto l2;
		}
		remLen = 4;
		goto l2;
	}
	else {
remLen = slotSizeOf(rem);
		goto l2;
	}
l2:	/* end digitLength: */;
	pQuo = firstIndexableField(quo);
	/* begin digitLength: */
	if (isIntegerObject(quo)) {
		/* begin cDigitLengthOfCSI: */
		if (((integerValueOf(quo)) < 256)
		 && ((integerValueOf(quo)) > -256)) {
			quoLen = 1;
			goto l3;
		}
		if (((integerValueOf(quo)) < 65536)
		 && ((integerValueOf(quo)) > -65536)) {
			quoLen = 2;
			goto l3;
		}
		if (((integerValueOf(quo)) < 0x1000000)
		 && ((integerValueOf(quo)) > -16777216)) {
			quoLen = 3;
			goto l3;
		}
		quoLen = 4;
		goto l3;
	}
	else {
quoLen = slotSizeOf(quo);
		goto l3;
	}
l3:	/* end digitLength: */;

	/* Last actual byte of data (ST ix) */

dl = divLen - 1;
	ql = quoLen;
	dh = pDiv[dl - 1];
	if (dl == 1) {
dnh = 0;
	}
	else {
dnh = pDiv[dl - 2];
	}
	for (k = 1; k <= ql; k += 1) {

		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two bytes of rem by dh. */
		/* The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles. */
		/* Nibbles are kicked off! We use full 16 bits now, because we are in
		   the year 2000 ;-) [sr] */
		/* r1 := rem digitAt: j. */


		/* maintain quo*arg+rem=self */
		/* Estimate rem/div by dividing the leading two bytes of rem by dh. */
		/* The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles. */
		/* Nibbles are kicked off! We use full 16 bits now, because we are in
		   the year 2000 ;-) [sr] */
		/* r1 := rem digitAt: j. */

j = (remLen + 1) - k;
		if ((pRem[j - 1]) == dh) {
			q = 0xFF;
		}
		else {

			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are bytes, not nibbles.
			   Be careful not to generate intermediate results exceeding 13
			   bits. */
			/* r2 := (rem digitAt: j - 2). */


			/* Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.
			   Note that r1,r2 are bytes, not nibbles.
			   Be careful not to generate intermediate results exceeding 13
			   bits. */
			/* r2 := (rem digitAt: j - 2). */

r1r2 = (((usqInt) (pRem[j - 1]) << 8)) + (pRem[j - 2]);
			t = r1r2 % dh;

			/* Next compute (hi,lo) := q*dnh */

q = r1r2 / dh;
			mul = q * dnh;
			hi = ((usqInt) mul >> 8);

			/* Correct overestimate of q.
			   Max of 2 iterations through loop -- see Knuth vol. 2 */

			lo = mul & 0xFF;
			if (j < 3) {
r3 = 0;
			}
			else {
r3 = pRem[j - 3];
			}
			while (1) {
if ((t < hi)
				 || ((t == hi)
				 && (r3 < lo))) {

					/* i.e. (t,r3) < (hi,lo) */


					/* i.e. (t,r3) < (hi,lo) */

q -= 1;
					lo -= dnh;
					if (lo < 0) {
hi -= 1;
						lo += 256;
					}
					cond = hi >= dh;
				}
				else {
cond = 0;
				}
				if (!(cond)) break;
				hi -= dh;
			}
		}
		l1 = j - dl;
		a = 0;
		for (i = 1; i <= divLen; i += 1) {
hi = (pDiv[i - 1]) * (((usqInt) q >> 8));

			/* pRem at: l - 1 put: lo - (lo // 256 * 256). */
			/* sign-tolerant form of (lo bitAnd: 255) -> obsolete... */

lo = (a + (pRem[l1 - 1])) - ((pDiv[i - 1]) * (q & 0xFF));
			pRem[l1 - 1] = (lo & 0xFF);
			a = (((sqInt) lo >> 8)) - hi;
			l1 += 1;
		}
		if (a < 0) {

			/* Add div back into rem, decrease q by 1 */


			/* Add div back into rem, decrease q by 1 */

q -= 1;
			l1 = j - dl;
			a = 0;
			for (i = 1; i <= divLen; i += 1) {
a = ((((usqInt) a >> 8)) + (pRem[l1 - 1])) + (pDiv[i - 1]);
				pRem[l1 - 1] = (a & 0xFF);
				l1 += 1;
			}
		}
		pQuo[quoLen - k] = q;
	}
	pushRemappableOop(quo);
rem = bytesRshiftbyteslookfirst(rem, d, 0, (digitLength(div)) - 1);
	quo = popRemappableOop();
	pushRemappableOop(quo);
	pushRemappableOop(rem);
result = instantiateClassindexableSize(classArray(), 2);
	rem = popRemappableOop();
	quo = popRemappableOop();
	stObjectatput(result,1,quo);
	stObjectatput(result,2,rem);
	return result;
}

static sqInt
digitLength(sqInt oop)
{
	// LargeIntegersPlugin>>#digitLength:
	if (isIntegerObject(oop)) {
		/* begin cDigitLengthOfCSI: */
		if (((integerValueOf(oop)) < 256)
		 && ((integerValueOf(oop)) > -256)) {
			return 1;
		}
		if (((integerValueOf(oop)) < 65536)
		 && ((integerValueOf(oop)) > -65536)) {
			return 2;
		}
		if (((integerValueOf(oop)) < 0x1000000)
		 && ((integerValueOf(oop)) > -16777216)) {
			return 3;
		}
		return 4;
	}
	else {
return slotSizeOf(oop);
	}
}

static sqInt
digitMontgomerytimesmodulomInvModB(sqInt firstLarge, sqInt secondLarge, sqInt thirdLarge, sqInt mInv)
{
	// LargeIntegersPlugin>>#digitMontgomery:times:modulo:mInvModB:
	usqInt  accum;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned char   lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char *  pBytesFirst;
	unsigned char *  pBytesRes;
	unsigned char *  pBytesSecond;
	unsigned char *  pBytesThird;
	sqInt prod;
	sqInt secondLen;
	sqInt thirdLen;
	unsigned char   u;

	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	thirdLen = slotSizeOf(thirdLarge);
	if (!(firstLen <= thirdLen)) {
		return primitiveFail();
	}
	if (!(secondLen <= thirdLen)) {
		return primitiveFail();
	}
	if (!((mInv >= 0)
		 && (mInv <= 0xFF))) {
		return primitiveFail();
	}
	pushRemappableOop(firstLarge);
	pushRemappableOop(secondLarge);
	pushRemappableOop(thirdLarge);
prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);
	thirdLarge = popRemappableOop();
	secondLarge = popRemappableOop();
	firstLarge = popRemappableOop();
	/* begin cdigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
	pBytesFirst = firstIndexableField(firstLarge);
	pBytesSecond = firstIndexableField(secondLarge);
	pBytesThird = firstIndexableField(thirdLarge);
	pBytesRes = firstIndexableField(prod);
	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
accum = pBytesRes[0];
		u = (accum * mInv) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */


		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */

accum = 0;
		for (i = 0; i <= limit3; i += 1) {
accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = (accum - ((((sqInt) accum >> 8)) * 256));
			accum = ((sqInt) accum >> 8);
		}
	}
	return normalizePositive(prod);
}


/*	Normalizes. */

static sqInt
digitMultiplyLargewithnegative(sqInt firstInteger, sqInt secondInteger, sqInt neg)
{
	// LargeIntegersPlugin>>#digitMultiplyLarge:with:negative:
	sqInt ab;
	sqInt carry;
	sqInt digit;
	sqInt firstLen;
	sqInt i;
	sqInt j;
	sqInt k;
	sqInt limitLong;
	sqInt limitShort;
	sqInt longInt;
	sqInt longLen;
	unsigned char *  pByteLong;
	unsigned char *  pByteRes;
	unsigned char *  pByteShort;
	sqInt prod;
	sqInt resultClass;
	sqInt secondLen;
	sqInt shortInt;
	sqInt shortLen;

	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (firstLen <= secondLen) {
shortInt = firstInteger;
		shortLen = firstLen;
		longInt = secondInteger;
		longLen = secondLen;
	}
	else {
shortInt = secondInteger;
		shortLen = secondLen;
		longInt = firstInteger;
		longLen = firstLen;
	}
	if (neg) {
resultClass = classLargeNegativeInteger();
	}
	else {
resultClass = classLargePositiveInteger();
	}
	pushRemappableOop(shortInt);
	pushRemappableOop(longInt);
prod = instantiateClassindexableSize(resultClass, longLen + shortLen);
	longInt = popRemappableOop();
	shortInt = popRemappableOop();
	/* begin cDigitMultiply:len:with:len:into: */
	pByteShort = firstIndexableField(shortInt);
	pByteLong = firstIndexableField(longInt);
	pByteRes = firstIndexableField(prod);
	if ((shortLen == 1)
	 && ((pByteShort[0]) == 0)) {
		0;
		goto l1;
	}
	if ((longLen == 1)
	 && ((pByteLong[0]) == 0)) {
		0;
		goto l1;
	}
	limitShort = shortLen - 1;
	for (i = 0; i <= limitShort; i += 1) {
if (((digit = pByteShort[i])) != 0) {
			k = i;

			/* Loop invariant: 0<=carry<=0377, k=i+j-1 (ST) */
			/* -> Loop invariant: 0<=carry<=0377, k=i+j (C) (?) */

carry = 0;
			limitLong = longLen - 1;
			for (j = 0; j <= limitLong; j += 1) {
ab = (((pByteLong[j]) * digit) + carry) + (pByteRes[k]);
				carry = ((usqInt) ab >> 8);
				pByteRes[k] = (ab & 0xFF);
				k += 1;
			}
			pByteRes[k] = carry;
		}
	}
	0;
l1:	/* end cDigitMultiply:len:with:len:into: */;
	/* begin normalize: */
	/* missing DebugCode */;
	if ((fetchClassOf(prod)) == (classLargePositiveInteger())) {
		return normalizePositive(prod);
	}
	else {
return normalizeNegative(prod);
	}
}


/*	Argument has to be aLargeInteger! */

static sqInt
digitOfBytesat(sqInt aBytesOop, sqInt ix)
{
	// LargeIntegersPlugin>>#digitOfBytes:at:
	unsigned char *pointer;

	if (ix > (slotSizeOf(aBytesOop))) {
		return 0;
	}
	else {
return ((pointer = firstIndexableField(aBytesOop)))[ix - 1];
	}
}

static sqInt
digitOfat(sqInt oop, sqInt ix)
{
	// LargeIntegersPlugin>>#digitOf:at:
	unsigned char *pointer;

	if (isIntegerObject(oop)) {
		return cDigitOfCSIat(integerValueOf(oop), ix);
	}
	else {
/* begin digitOfBytes:at: */
		if (ix > (slotSizeOf(oop))) {
			return 0;
		}
		else {
return ((pointer = firstIndexableField(oop)))[ix - 1];
		}
	}
}


/*	Normalizes. */

static sqInt
digitSubLargewith(sqInt firstInteger, sqInt secondInteger)
{
	// LargeIntegersPlugin>>#digitSubLarge:with:
	sqInt firstLen;
	sqInt firstNeg;
	sqInt i;
	sqInt larger;
	sqInt largerLen;
	sqInt limit;
	sqInt neg;
	unsigned char *  pByteLarge;
	unsigned char *  pByteRes;
	unsigned char *  pByteSmall;
	sqInt res;
	sqInt resLen;
	sqInt secondLen;
	sqInt smaller;
	sqInt smallerLen;
	sqInt z;

	firstNeg = (fetchClassOf(firstInteger)) == (classLargeNegativeInteger());
	firstLen = slotSizeOf(firstInteger);
	secondLen = slotSizeOf(secondInteger);
	if (firstLen == secondLen) {
while ((firstLen > 1)
		 && ((digitOfBytesat(firstInteger, firstLen)) == (digitOfBytesat(secondInteger, firstLen)))) {
			firstLen -= 1;
		}
		secondLen = firstLen;
	}
	if ((firstLen < secondLen)
	 || ((firstLen == secondLen)
	 && ((digitOfBytesat(firstInteger, firstLen)) < (digitOfBytesat(secondInteger, firstLen))))) {
		larger = secondInteger;
		largerLen = secondLen;
		smaller = firstInteger;
		smallerLen = firstLen;
		neg = firstNeg == 0;
	}
	else {
larger = firstInteger;
		largerLen = firstLen;
		smaller = secondInteger;
		smallerLen = secondLen;
		neg = firstNeg;
	}
	resLen = largerLen;
	pushRemappableOop(smaller);
	pushRemappableOop(larger);
res = instantiateClassindexableSize((neg
		? classLargeNegativeInteger()
		: classLargePositiveInteger()), resLen);
	larger = popRemappableOop();
	smaller = popRemappableOop();
	/* begin cDigitSub:len:with:len:into: */
	pByteSmall = firstIndexableField(smaller);
	pByteLarge = firstIndexableField(larger);
	pByteRes = firstIndexableField(res);

	/* Loop invariant is -1<=z<=1 */

z = 0;
	limit = smallerLen - 1;
	for (i = 0; i <= limit; i += 1) {
z = (z + (pByteLarge[i])) - (pByteSmall[i]);
		pByteRes[i] = (z - ((((sqInt) z >> 8)) * 256));
		z = ((sqInt) z >> 8);
	}
	limit = largerLen - 1;
	for (i = smallerLen; i <= limit; i += 1) {
z += pByteLarge[i];
		pByteRes[i] = (z - ((((sqInt) z >> 8)) * 256));
		z = ((sqInt) z >> 8);
	}
	return (neg
		? normalizeNegative(res)
		: normalizePositive(res));
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	// InterpreterPlugin>>#getInterpreter
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	// InterpreterPlugin>>#getModuleName
	return moduleName;
}

static sqInt
halt(void)
{
	// InterpreterPlugin>>#halt
	;
	return 0;
}

static sqInt
highBitOfBytes(sqInt aBytesOop)
{
	// LargeIntegersPlugin>>#highBitOfBytes:
	sqInt lastDigit;
	sqInt len;
	unsigned char *   pByte;
	sqInt realLength;

	/* begin cBytesHighBit:len: */
	pByte = firstIndexableField(aBytesOop);
	len = slotSizeOf(aBytesOop);
	realLength = len;
	while (((lastDigit = pByte[realLength - 1])) == 0) {
		if (((realLength -= 1)) == 0) {
			return 0;
		}
	}
	return (cHighBit(lastDigit)) + (8 * (realLength - 1));
}

static sqInt
isNormalized(sqInt anInteger)
{
	// LargeIntegersPlugin>>#isNormalized:
	sqInt ix;
	sqInt len;
	sqInt maxVal;
	sqInt minVal;
	unsigned char *pointer;
	unsigned char *pointer1;
	unsigned char *pointer2;
	unsigned char *pointer3;
	sqInt sLen;

	if (isIntegerObject(anInteger)) {
		return 1;
	}
	/* begin digitLength: */
	if (isIntegerObject(anInteger)) {
		/* begin cDigitLengthOfCSI: */
		if (((integerValueOf(anInteger)) < 256)
		 && ((integerValueOf(anInteger)) > -256)) {
			len = 1;
			goto l1;
		}
		if (((integerValueOf(anInteger)) < 65536)
		 && ((integerValueOf(anInteger)) > -65536)) {
			len = 2;
			goto l1;
		}
		if (((integerValueOf(anInteger)) < 0x1000000)
		 && ((integerValueOf(anInteger)) > -16777216)) {
			len = 3;
			goto l1;
		}
		len = 4;
		goto l1;
	}
	else {
len = slotSizeOf(anInteger);
		goto l1;
	}
l1:	/* end digitLength: */;
	if (len == 0) {
return 0;
	}
	if ((((pointer = firstIndexableField(anInteger)))[len - 1]) == 0) {
		return 0;
	}

	/* maximal digitLength of aSmallInteger */

sLen = 4;
	if (len > sLen) {
return 1;
	}
	if (len < sLen) {
return 0;
	}
	if ((fetchClassOf(anInteger)) == (classLargePositiveInteger())) {

		/* SmallInteger maxVal */
		/* all bytes of maxVal but the highest one are just FF's */

maxVal = 0x3FFFFFFF;
		return (((pointer1 = firstIndexableField(anInteger)))[sLen - 1]) > (cDigitOfCSIat(maxVal, sLen));
	}
	else {

		/* SmallInteger minVal */
		/* all bytes of minVal but the highest one are just 00's */

minVal = -1073741824;
		if ((((pointer2 = firstIndexableField(anInteger)))[sLen - 1]) < (cDigitOfCSIat(minVal, sLen))) {
			return 0;
		}
		else {

			/* if just one digit differs, then anInteger < minval (the corresponding digit byte is greater!)
			   and therefore a LargeNegativeInteger */

			for (ix = 1; ix <= sLen; ix += 1) {

				/* if just one digit differs, then anInteger < minval (the corresponding digit byte is greater!)
				   and therefore a LargeNegativeInteger */

				if (!((((pointer3 = firstIndexableField(anInteger)))[ix - 1]) == (cDigitOfCSIat(minVal, ix)))) {

					/* if just one digit differs, then anInteger < minval (the corresponding digit byte is greater!)
					   and therefore a LargeNegativeInteger */

					return 1;
				}
			}
		}
	}
	return 0;
}

static sqInt
msg(char *s)
{
	// InterpreterPlugin>>#msg:
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

static sqInt
negative(sqInt aLarge)
{
	// LargeIntegersPlugin>>#negative:
	return (fetchClassOf(aLarge)) == (classLargeNegativeInteger());
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

static sqInt
normalizeNegative(sqInt aLargeNegativeInteger)
{
	// LargeIntegersPlugin>>#normalizeNegative:
	sqInt i;
	sqInt len;
	sqInt minVal;
	sqInt oldLen;
	unsigned char *pointer;
	unsigned char *pointer1;
	sqInt sLen;
	sqInt val;

	len = (oldLen = digitLength(aLargeNegativeInteger));
	while ((len != 0)
	 && ((((pointer = firstIndexableField(aLargeNegativeInteger)))[len - 1]) == 0)) {
		len -= 1;
	}
	if (len == 0) {
return integerObjectOf(0);
	}

	/* SmallInteger minVal digitLength */

sLen = 4;
	if (len <= sLen) {

		/* SmallInteger minVal */


		/* SmallInteger minVal */

minVal = -1073741824;
		if ((len < sLen)
		 || ((digitOfBytesat(aLargeNegativeInteger, sLen)) < (cDigitOfCSIat(minVal, sLen)))) {

			/* If high digit less, then can be small */


			/* If high digit less, then can be small */

val = 0;
			for (i = len; i >= 1; i += -1) {
val = (val * 256) - (((pointer1 = firstIndexableField(aLargeNegativeInteger)))[i - 1]);
			}
			return integerObjectOf(val);
		}
		for (i = 1; i <= sLen; i += 1) {

			/* If all digits same, then = minVal (sr: minVal digits 1 to 3 are
			   0) */
			/* Not so; return self shortened */
			/* ^ self growto: len */

if (!((digitOfBytesat(aLargeNegativeInteger, i)) == (cDigitOfCSIat(minVal, i)))) {

				/* If all digits same, then = minVal (sr: minVal digits 1 to 3 are
				   0) */
				/* Not so; return self shortened */
				/* ^ self growto: len */

if (len < oldLen) {

					/* If all digits same, then = minVal (sr: minVal digits 1 to 3 are
					   0) */
					/* Not so; return self shortened */
					/* ^ self growto: len */

return bytesgrowTo(aLargeNegativeInteger, len);
				}
				else {
return aLargeNegativeInteger;
				}
			}
		}
		return integerObjectOf(minVal);
	}
	if (len < oldLen) {

		/* ^ self growto: len */

return bytesgrowTo(aLargeNegativeInteger, len);
	}
	else {
return aLargeNegativeInteger;
	}
}


/*	Check for leading zeroes and return shortened copy if so. */
/*	First establish len = significant length. */

static sqInt
normalizePositive(sqInt aLargePositiveInteger)
{
	// LargeIntegersPlugin>>#normalizePositive:
	sqInt i;
	sqInt len;
	sqInt oldLen;
	unsigned char *pointer;
	unsigned char *pointer1;
	sqInt sLen;
	sqInt val;

	len = (oldLen = digitLength(aLargePositiveInteger));
	while ((len != 0)
	 && ((((pointer = firstIndexableField(aLargePositiveInteger)))[len - 1]) == 0)) {
		len -= 1;
	}
	if (len == 0) {
return integerObjectOf(0);
	}

	/* SmallInteger maxVal digitLength. */

sLen = 4;
	if ((len <= sLen)
	 && ((digitOfBytesat(aLargePositiveInteger, sLen)) <= (cDigitOfCSIat(0x3FFFFFFF, sLen)))) {

		/* If so, return its SmallInt value */


		/* If so, return its SmallInt value */

val = 0;
		for (i = len; i >= 1; i += -1) {
val = (val * 256) + (((pointer1 = firstIndexableField(aLargePositiveInteger)))[i - 1]);
		}
		return integerObjectOf(val);
	}
	if (len < oldLen) {

		/* ^ self growto: len */

return bytesgrowTo(aLargePositiveInteger, len);
	}
	else {
return aLargePositiveInteger;
	}
}


/*	Check for leading zeroes and return shortened copy if so. */

static sqInt
normalize(sqInt aLargeInteger)
{
	// LargeIntegersPlugin>>#normalize:
	/* missing DebugCode */;
	if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
		return normalizePositive(aLargeInteger);
	}
	else {
return normalizeNegative(aLargeInteger);
	}
}

EXPORT(sqInt)
primAnyBitFromTo(void)
{
	// LargeIntegersPlugin>>#primAnyBitFromTo
	sqInt from;
	sqInt integer;
	sqInt large;
	sqInt to;
	sqInt _return_value;

	from = stackIntegerValue(1);
	to = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	integer = stackValue(2);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(integer)) {

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

large = createLargeFromSmallInteger(integer);
	}
	else {
large = integer;
	}
	_return_value = (((anyBitOfBytesfromto(large, from, to))) ? trueObject() : falseObject());
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Converts a SmallInteger into a - non normalized! - LargeInteger; 
	aLargeInteger will be returned unchanged. */
/*	Do not check for forced fail, because we need this conversion to test the 
	plugin in ST during forced fail, too. */

EXPORT(sqInt)
primAsLargeInteger(void)
{
	// LargeIntegersPlugin>>#primAsLargeInteger
	sqInt anInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	anInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {
		_return_value = createLargeFromSmallInteger(anInteger);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
if (failed()) {
			return null;
		}
		popthenPush(2, anInteger);
		return null;
	}
}


/*	If calling this primitive fails, then C module does not exist. Do not
	check for forced fail, because we want to know if module exists during
	forced fail, too.
 */

EXPORT(sqInt)
primCheckIfCModuleExists(void)
{
	// LargeIntegersPlugin>>#primCheckIfCModuleExists
	sqInt _return_value;

	_return_value = ((1) ? trueObject() : falseObject());
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitAdd(void)
{
	// LargeIntegersPlugin>>#primDigitAdd
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitAddLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitAddWith(void)
{
	// LargeIntegersPlugin>>#primDigitAddWith
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitAddLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

EXPORT(sqInt)
primDigitBitAnd(void)
{
	// LargeIntegersPlugin>>#primDigitBitAnd
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, andOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if any
	arg is negative, it fails.
 */

EXPORT(sqInt)
primDigitBitLogicWithOp(void)
{
	// LargeIntegersPlugin>>#primDigitBitLogicWithOp
	sqInt firstInteger;
	sqInt opIndex;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	opIndex = stackIntegerValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, opIndex);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

EXPORT(sqInt)
primDigitBitOr(void)
{
	// LargeIntegersPlugin>>#primDigitBitOr
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, orOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitBitShift(void)
{
	// LargeIntegersPlugin>>#primDigitBitShift
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
aLarge = anInteger;
	}
	if (shiftCount >= 0) {
_return_value = bytesLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
rShift = 0 - shiftCount;
		/* begin normalize: */
		aLargeInteger = bytesRshiftbyteslookfirst(aLarge, rShift & 7, ((usqInt) rShift >> 3), slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
}

EXPORT(sqInt)
primDigitBitShiftMagnitude(void)
{
	// LargeIntegersPlugin>>#primDigitBitShiftMagnitude
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
aLarge = anInteger;
	}
	if (shiftCount >= 0) {
_return_value = bytesLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
	else {
rShift = 0 - shiftCount;
		/* begin normalize: */
		aLargeInteger = bytesRshiftbyteslookfirst(aLarge, rShift & 7, ((usqInt) rShift >> 3), slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(2, _return_value);
		return null;
	}
}


/*	Bit logic here is only implemented for positive integers or Zero; if rec 
	or arg is negative, it fails. */

EXPORT(sqInt)
primDigitBitXor(void)
{
	// LargeIntegersPlugin>>#primDigitBitXor
	sqInt firstInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	_return_value = digitBitLogicwithopIndex(firstInteger, secondInteger, xorOpIndex);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitCompare(void)
{
	// LargeIntegersPlugin>>#primDigitCompare
	sqInt firstInteger;
	sqInt firstVal;
	sqInt secondInteger;
	sqInt secondVal;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* first */
		/* second */
		/* first > second */

if (isIntegerObject(secondInteger)) {

			/* first */
			/* second */
			/* first > second */

if (((firstVal = integerValueOf(firstInteger))) > ((secondVal = integerValueOf(secondInteger)))) {

				/* first */
				/* second */
				/* first > second */

_return_value = integerObjectOf(1);
				if (failed()) {
					return null;
				}
				popthenPush(2, _return_value);
				return null;
			}
			else {
if (firstVal < secondVal) {
_return_value = integerObjectOf(-1);
					if (failed()) {
						return null;
					}
					popthenPush(2, _return_value);
					return null;
				}
				else {
_return_value = integerObjectOf(0);
					if (failed()) {
						return null;
					}
					popthenPush(2, _return_value);
					return null;
				}
			}
		}
		else {

			/* SECOND */
			/* first < SECOND */

_return_value = integerObjectOf(-1);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
	}
	else {

		/* FIRST */
		/* second */
		/* FIRST > second */

if (isIntegerObject(secondInteger)) {

			/* FIRST */
			/* second */
			/* FIRST > second */

_return_value = integerObjectOf(1);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
		else {

			/* SECOND */

_return_value = digitCompareLargewith(firstInteger, secondInteger);
			if (failed()) {
				return null;
			}
			popthenPush(2, _return_value);
			return null;
		}
	}
}

EXPORT(sqInt)
primDigitCompareWith(void)
{
	// LargeIntegersPlugin>>#primDigitCompareWith
	sqInt firstInteger;
	sqInt firstVal;
	sqInt secondInteger;
	sqInt secondVal;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* first */
		/* second */
		/* first > second */

if (isIntegerObject(secondInteger)) {

			/* first */
			/* second */
			/* first > second */

if (((firstVal = integerValueOf(firstInteger))) > ((secondVal = integerValueOf(secondInteger)))) {

				/* first */
				/* second */
				/* first > second */

_return_value = integerObjectOf(1);
				if (failed()) {
					return null;
				}
				popthenPush(3, _return_value);
				return null;
			}
			else {
if (firstVal < secondVal) {
_return_value = integerObjectOf(-1);
					if (failed()) {
						return null;
					}
					popthenPush(3, _return_value);
					return null;
				}
				else {
_return_value = integerObjectOf(0);
					if (failed()) {
						return null;
					}
					popthenPush(3, _return_value);
					return null;
				}
			}
		}
		else {

			/* SECOND */
			/* first < SECOND */

_return_value = integerObjectOf(-1);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
	}
	else {

		/* FIRST */
		/* second */
		/* FIRST > second */

if (isIntegerObject(secondInteger)) {

			/* FIRST */
			/* second */
			/* FIRST > second */

_return_value = integerObjectOf(1);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
		else {

			/* SECOND */

_return_value = digitCompareLargewith(firstInteger, secondInteger);
			if (failed()) {
				return null;
			}
			popthenPush(3, _return_value);
			return null;
		}
	}
}


/*	Answer the result of dividing firstInteger by secondInteger. 
	Fail if parameters are not integers, not normalized or secondInteger is 
	zero. */

EXPORT(sqInt)
primDigitDivNegative(void)
{
	// LargeIntegersPlugin>>#primDigitDivNegative
	sqInt firstAsLargeInteger;
	sqInt firstInteger;
	sqInt neg;
	sqInt secondAsLargeInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	if (failed()) {
		return null;
	}
	if (!(isNormalized(firstInteger))) {
		/* missing DebugCode */;
		primitiveFail();
		return null;
	}
	if (!(isNormalized(secondInteger))) {
		/* missing DebugCode */;
		primitiveFail();
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert to LargeInteger */

pushRemappableOop(secondInteger);

		/* convert to LargeInteger */


		/* convert to LargeInteger */

firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstAsLargeInteger = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* check for zerodivide and convert to LargeInteger */

if ((integerValueOf(secondInteger)) == 0) {

			/* check for zerodivide and convert to LargeInteger */

primitiveFail();
			return null;
		}
		pushRemappableOop(firstAsLargeInteger);
secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);
		firstAsLargeInteger = popRemappableOop();
	}
	else {
secondAsLargeInteger = secondInteger;
	}
	_return_value = digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	Answer the result of dividing firstInteger by secondInteger.
	Fail if parameters are not integers or secondInteger is zero. */

EXPORT(sqInt)
primDigitDivWithNegative(void)
{
	// LargeIntegersPlugin>>#primDigitDivWithNegative
	sqInt firstAsLargeInteger;
	sqInt firstInteger;
	sqInt neg;
	sqInt secondAsLargeInteger;
	sqInt secondInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert to LargeInteger */

pushRemappableOop(secondInteger);

		/* convert to LargeInteger */


		/* convert to LargeInteger */

firstAsLargeInteger = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstAsLargeInteger = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* check for zerodivide and convert to LargeInteger */

if ((integerValueOf(secondInteger)) == 0) {

			/* check for zerodivide and convert to LargeInteger */

primitiveFail();
			return null;
		}
		pushRemappableOop(firstAsLargeInteger);
secondAsLargeInteger = createLargeFromSmallInteger(secondInteger);
		firstAsLargeInteger = popRemappableOop();
	}
	else {
secondAsLargeInteger = secondInteger;
	}
	_return_value = digitDivLargewithnegative(firstAsLargeInteger, secondAsLargeInteger, neg);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitMultiplyNegative(void)
{
	// LargeIntegersPlugin>>#primDigitMultiplyNegative
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt neg;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitMultiplyLargewithnegative(firstLarge, secondLarge, neg);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitMultiplyWithNegative(void)
{
	// LargeIntegersPlugin>>#primDigitMultiplyWithNegative
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt neg;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	firstInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	secondInteger = stackValue(1);
	neg = booleanValueOf(stackValue(0));
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitMultiplyLargewithnegative(firstLarge, secondLarge, neg);
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitSubtract(void)
{
	// LargeIntegersPlugin>>#primDigitSubtract
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitSubLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primDigitSubtractWith(void)
{
	// LargeIntegersPlugin>>#primDigitSubtractWith
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt secondInteger;
	sqInt secondLarge;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	firstInteger = stackValue(1);
	success(isKindOf(stackValue(0), "Integer"));
	secondInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		secondInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondInteger);
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondInteger;
	}
	_return_value = digitSubLargewith(firstLarge, secondLarge);
	if (failed()) {
		return null;
	}
	popthenPush(3, _return_value);
	return null;
}


/*	If calling this primitive fails, then C module does not exist. */

EXPORT(sqInt)
primGetModuleName(void)
{
	// LargeIntegersPlugin>>#primGetModuleName
	sqInt i;
	sqInt strLen;
	sqInt strOop;
	char *strPtr;

	/* missing DebugCode */;
	strLen = strlen(getModuleName());
	strOop = instantiateClassindexableSize(classString(), strLen);
	strPtr = firstIndexableField(strOop);
	for (i = 0; i < strLen; i += 1) {
strPtr[i] = ((getModuleName())[i]);
	}
	if (failed()) {
		return null;
	}
	popthenPush(1, strOop);
	return null;
}

EXPORT(sqInt)
primMontgomeryTimesModulo(void)
{
	// LargeIntegersPlugin>>#primMontgomeryTimesModulo
	usqInt  accum;
	sqInt firstInteger;
	sqInt firstLarge;
	sqInt firstLen;
	sqInt i;
	sqInt k;
	unsigned char   lastByte;
	sqInt limit1;
	sqInt limit2;
	sqInt limit3;
	unsigned char *  pBytesFirst;
	unsigned char *  pBytesRes;
	unsigned char *  pBytesSecond;
	unsigned char *  pBytesThird;
	sqInt prod;
	sqInt secondLarge;
	sqInt secondLen;
	sqInt secondOperandInteger;
	sqInt smallInverseInteger;
	sqInt thirdLarge;
	sqInt thirdLen;
	sqInt thirdModuloInteger;
	unsigned char   u;
	sqInt _return_value;

	success(isKindOf(stackValue(2), "Integer"));
	secondOperandInteger = stackValue(2);
	success(isKindOf(stackValue(1), "Integer"));
	thirdModuloInteger = stackValue(1);
	smallInverseInteger = stackIntegerValue(0);
	/* missing DebugCode */;
	success(isKindOf(stackValue(3), "Integer"));
	firstInteger = stackValue(3);
	if (failed()) {
		return null;
	}
	if (isIntegerObject(firstInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(secondOperandInteger);
		pushRemappableOop(thirdModuloInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

firstLarge = createLargeFromSmallInteger(firstInteger);
		thirdModuloInteger = popRemappableOop();
		secondOperandInteger = popRemappableOop();
	}
	else {
firstLarge = firstInteger;
	}
	if (isIntegerObject(secondOperandInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);
		pushRemappableOop(thirdModuloInteger);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

secondLarge = createLargeFromSmallInteger(secondOperandInteger);
		thirdModuloInteger = popRemappableOop();
		firstLarge = popRemappableOop();
	}
	else {
secondLarge = secondOperandInteger;
	}
	if (isIntegerObject(thirdModuloInteger)) {

		/* convert it to a not normalized LargeInteger */

pushRemappableOop(firstLarge);
		pushRemappableOop(secondLarge);

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

thirdLarge = createLargeFromSmallInteger(thirdModuloInteger);
		secondLarge = popRemappableOop();
		firstLarge = popRemappableOop();
	}
	else {
thirdLarge = thirdModuloInteger;
	}
	/* begin digitMontgomery:times:modulo:mInvModB: */
	firstLen = slotSizeOf(firstLarge);
	secondLen = slotSizeOf(secondLarge);
	thirdLen = slotSizeOf(thirdLarge);
	if (!(firstLen <= thirdLen)) {
		_return_value = primitiveFail();
		goto l1;
	}
	if (!(secondLen <= thirdLen)) {
		_return_value = primitiveFail();
		goto l1;
	}
	if (!((smallInverseInteger >= 0)
		 && (smallInverseInteger <= 0xFF))) {
		_return_value = primitiveFail();
		goto l1;
	}
	pushRemappableOop(firstLarge);
	pushRemappableOop(secondLarge);
	pushRemappableOop(thirdLarge);
prod = instantiateClassindexableSize(classLargePositiveInteger(), thirdLen);
	thirdLarge = popRemappableOop();
	secondLarge = popRemappableOop();
	firstLarge = popRemappableOop();
	/* begin cdigitMontgomery:len:times:len:modulo:len:mInvModB:into: */
	pBytesFirst = firstIndexableField(firstLarge);
	pBytesSecond = firstIndexableField(secondLarge);
	pBytesThird = firstIndexableField(thirdLarge);
	pBytesRes = firstIndexableField(prod);
	limit1 = firstLen - 1;
	limit2 = secondLen - 1;
	limit3 = thirdLen - 1;
	lastByte = 0;
	for (i = 0; i <= limit1; i += 1) {
accum = (pBytesRes[0]) + ((pBytesFirst[i]) * (pBytesSecond[0]));
		u = (accum * smallInverseInteger) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit2; k += 1) {
accum = (((((usqInt) accum) >> 8) + (pBytesRes[k])) + ((pBytesFirst[i]) * (pBytesSecond[k]))) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		for (k = secondLen; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	for (i = firstLen; i <= limit3; i += 1) {
accum = pBytesRes[0];
		u = (accum * smallInverseInteger) & 0xFF;
		accum += u * (pBytesThird[0]);
		for (k = 1; k <= limit3; k += 1) {
accum = ((((usqInt) accum) >> 8) + (pBytesRes[k])) + (u * (pBytesThird[k]));
			pBytesRes[k - 1] = (accum & 0xFF);
		}
		accum = (((usqInt) accum) >> 8) + lastByte;
		pBytesRes[limit3] = (accum & 0xFF);
		lastByte = ((usqInt) accum) >> 8;
	}
	if (!((lastByte == 0)
		 && ((cDigitComparewithlen(pBytesThird, pBytesRes, thirdLen)) == 1))) {

		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */


		/* self cDigitSub: pBytesThird len: thirdLen with: pBytesRes len: thirdLen into: pBytesRes */

accum = 0;
		for (i = 0; i <= limit3; i += 1) {
accum = (accum + (pBytesRes[i])) - (pBytesThird[i]);
			pBytesRes[i] = (accum - ((((sqInt) accum >> 8)) * 256));
			accum = ((sqInt) accum >> 8);
		}
	}
	_return_value = normalizePositive(prod);
l1:	/* end digitMontgomery:times:modulo:mInvModB: */;
	if (failed()) {
		return null;
	}
	popthenPush(4, _return_value);
	return null;
}


/*	Parameter specification #(Integer) doesn't convert! */

EXPORT(sqInt)
primNormalize(void)
{
	// LargeIntegersPlugin>>#primNormalize
	sqInt anInteger;
	sqInt _return_value;

	success(isKindOf(stackValue(0), "Integer"));
	anInteger = stackValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {
		if (failed()) {
			return null;
		}
		popthenPush(2, anInteger);
		return null;
	}
	/* begin normalize: */
	/* missing DebugCode */;
	if ((fetchClassOf(anInteger)) == (classLargePositiveInteger())) {
		_return_value = normalizePositive(anInteger);
		goto l1;
	}
	else {
_return_value = normalizeNegative(anInteger);
		goto l1;
	}
l1:	/* end normalize: */;
	if (failed()) {
		return null;
	}
	popthenPush(2, _return_value);
	return null;
}

EXPORT(sqInt)
primNormalizeNegative(void)
{
	// LargeIntegersPlugin>>#primNormalizeNegative
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isKindOf(stackValue(0), "LargeNegativeInteger"));
	rcvr = stackValue(0);
	if (failed()) {
		return null;
	}
	_return_value = normalizeNegative(rcvr);
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}

EXPORT(sqInt)
primNormalizePositive(void)
{
	// LargeIntegersPlugin>>#primNormalizePositive
	sqInt rcvr;
	sqInt _return_value;

	/* missing DebugCode */;
	success(isKindOf(stackValue(0), "LargePositiveInteger"));
	rcvr = stackValue(0);
	if (failed()) {
		return null;
	}
	_return_value = normalizePositive(rcvr);
	if (failed()) {
		return null;
	}
	popthenPush(1, _return_value);
	return null;
}


/*	Note: This is coded so that it can be run in Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
	// InterpreterPlugin>>#setInterpreter:
	sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {

#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		classArray = interpreterProxy->classArray;
		classLargeNegativeInteger = interpreterProxy->classLargeNegativeInteger;
		classLargePositiveInteger = interpreterProxy->classLargePositiveInteger;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		fetchClassOf = interpreterProxy->fetchClassOf;
		firstIndexableField = interpreterProxy->firstIndexableField;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		isKindOf = interpreterProxy->isKindOf;
		isIntegerObject = interpreterProxy->isIntegerObject;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		primitiveFail = interpreterProxy->primitiveFail;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stObjectatput = interpreterProxy->stObjectatput;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
		success = interpreterProxy->success;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

static sqInt
sqAssert(sqInt aBool)
{
	// SmartSyntaxInterpreterPlugin>>#sqAssert:
	/* missing DebugCode */;
}


/*	Flag for marking methods for later thinking. */

static sqInt
think(void)
{
	// LargeIntegersPlugin>>#think
	/* missing DebugCode */;
	return null;
}


/*	Argument bytesOop must not be aSmallInteger! */

static sqInt
unsafeByteOfat(sqInt bytesOop, sqInt ix)
{
	// LargeIntegersPlugin>>#unsafeByteOf:at:
	unsigned char *pointer;

	return ((pointer = firstIndexableField(bytesOop)))[ix - 1];
}

EXPORT(sqInt)
_primDigitBitShift(void)
{
	// LargeIntegersPlugin>>#_primDigitBitShift
	sqInt aLarge;
	sqInt aLargeInteger;
	sqInt anInteger;
	sqInt rShift;
	sqInt shiftCount;
	sqInt _return_value;

	success(isKindOf(stackValue(1), "Integer"));
	anInteger = stackValue(1);
	shiftCount = stackIntegerValue(0);
	/* missing DebugCode */;
	if (failed()) {
		return null;
	}
	if (isIntegerObject(anInteger)) {

		/* convert it to a not normalized LargeInteger */


		/* convert it to a not normalized LargeInteger */

aLarge = createLargeFromSmallInteger(anInteger);
	}
	else {
aLarge = anInteger;
	}
	if (shiftCount >= 0) {
_return_value = bytesLshift(aLarge, shiftCount);
		if (failed()) {
			return null;
		}
		popthenPush(3, _return_value);
		return null;
	}
	else {
rShift = 0 - shiftCount;
		/* begin normalize: */
		aLargeInteger = bytesRshiftbyteslookfirst(aLarge, rShift & 7, ((usqInt) rShift >> 3), slotSizeOf(aLarge));
		/* missing DebugCode */;
		if ((fetchClassOf(aLargeInteger)) == (classLargePositiveInteger())) {
			_return_value = normalizePositive(aLargeInteger);
			goto l1;
		}
		else {
_return_value = normalizeNegative(aLargeInteger);
			goto l1;
		}
	l1:	/* end normalize: */;
		if (failed()) {
			return null;
		}
		popthenPush(3, _return_value);
		return null;
	}
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* LargeIntegers_exports[][3] = {
	{"LargeIntegers", "getModuleName", (void*)getModuleName},
	{"LargeIntegers", "primAnyBitFromTo\000\002", (void*)primAnyBitFromTo},
	{"LargeIntegers", "primAsLargeInteger\000\001", (void*)primAsLargeInteger},
	{"LargeIntegers", "primCheckIfCModuleExists\000\377", (void*)primCheckIfCModuleExists},
	{"LargeIntegers", "primDigitAdd\000\002", (void*)primDigitAdd},
	{"LargeIntegers", "primDigitAddWith\000\002", (void*)primDigitAddWith},
	{"LargeIntegers", "primDigitBitAnd\000\002", (void*)primDigitBitAnd},
	{"LargeIntegers", "primDigitBitLogicWithOp\000\002", (void*)primDigitBitLogicWithOp},
	{"LargeIntegers", "primDigitBitOr\000\002", (void*)primDigitBitOr},
	{"LargeIntegers", "primDigitBitShift\000\004", (void*)primDigitBitShift},
	{"LargeIntegers", "primDigitBitShiftMagnitude\000\004", (void*)primDigitBitShiftMagnitude},
	{"LargeIntegers", "primDigitBitXor\000\002", (void*)primDigitBitXor},
	{"LargeIntegers", "primDigitCompare\000\001", (void*)primDigitCompare},
	{"LargeIntegers", "primDigitCompareWith\000\001", (void*)primDigitCompareWith},
	{"LargeIntegers", "primDigitDivNegative\000\004", (void*)primDigitDivNegative},
	{"LargeIntegers", "primDigitDivWithNegative\000\004", (void*)primDigitDivWithNegative},
	{"LargeIntegers", "primDigitMultiplyNegative\000\002", (void*)primDigitMultiplyNegative},
	{"LargeIntegers", "primDigitMultiplyWithNegative\000\002", (void*)primDigitMultiplyWithNegative},
	{"LargeIntegers", "primDigitSubtract\000\002", (void*)primDigitSubtract},
	{"LargeIntegers", "primDigitSubtractWith\000\002", (void*)primDigitSubtractWith},
	{"LargeIntegers", "primGetModuleName\000\377", (void*)primGetModuleName},
	{"LargeIntegers", "primMontgomeryTimesModulo\000\002", (void*)primMontgomeryTimesModulo},
	{"LargeIntegers", "primNormalize\000\001", (void*)primNormalize},
	{"LargeIntegers", "primNormalizeNegative\000\001", (void*)primNormalizeNegative},
	{"LargeIntegers", "primNormalizePositive\000\001", (void*)primNormalizePositive},
	{"LargeIntegers", "setInterpreter", (void*)setInterpreter},
	{"LargeIntegers", "_primDigitBitShift\000\004", (void*)_primDigitBitShift},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primAnyBitFromToAccessorDepth = 2;
signed char primAsLargeIntegerAccessorDepth = 1;
signed char primDigitAddAccessorDepth = 2;
signed char primDigitAddWithAccessorDepth = 2;
signed char primDigitBitAndAccessorDepth = 2;
signed char primDigitBitLogicWithOpAccessorDepth = 2;
signed char primDigitBitOrAccessorDepth = 2;
signed char primDigitBitShiftAccessorDepth = 4;
signed char primDigitBitShiftMagnitudeAccessorDepth = 4;
signed char primDigitBitXorAccessorDepth = 2;
signed char primDigitCompareAccessorDepth = 1;
signed char primDigitCompareWithAccessorDepth = 1;
signed char primDigitDivNegativeAccessorDepth = 4;
signed char primDigitDivWithNegativeAccessorDepth = 4;
signed char primDigitMultiplyNegativeAccessorDepth = 2;
signed char primDigitMultiplyWithNegativeAccessorDepth = 2;
signed char primDigitSubtractAccessorDepth = 2;
signed char primDigitSubtractWithAccessorDepth = 2;
signed char primMontgomeryTimesModuloAccessorDepth = 2;
signed char primNormalizeAccessorDepth = 1;
signed char primNormalizeNegativeAccessorDepth = 1;
signed char primNormalizePositiveAccessorDepth = 1;
signed char _primDigitBitShiftAccessorDepth = 4;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
